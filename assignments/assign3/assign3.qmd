---
title: "Assignment 3: Simulation"
author: "YOUR NAME HERE"
date: today
format:
    html:
      toc: true
      embed-resources: true
editor: visual
---

```{r}
#| warning: false

#Use install.packages("XXXX") if you don't have any of these installed
library(readxl)
library(flextable)
library(ggplot2)
library(dplyr)
library(scales)
library(data.table)
theme_set(theme_bw()) #Makes ggplots look better
```

# A. Simulated decision tree

In this section, you will implement an adapted version of the simulated decision tree from my papers about transfusion-transmitted Zika virus, discussed in class (Used in [Russell et. al. 2019](https://doi.org/10.7326/M18-2238), [Russell et. al. 2021](https://www.doi.org/10.1007/s10729-021-09557-1), and [Russell 2022](https://doi.org/10.7326/M20-6879)). You will employ two variation reduction techniques: simulating outcomes on the same cohort across each scenario and conditional Monte Carlo, to improve the efficiency of the analysis. Lets get started!

We will assess a hypothetical pathogen inactivation technology that reduces the risk of transfusion-transmitted Zika by 95% and costs \$18 per component transfused. As depicted below, the full simulation model consider adverse events to the transfusion recipient, their sexual partner, and an infant born to the transfusion recipient (if pregnant at the time of transfusion) or sexual partner (if pregnant at the time of sexual transmission). However, we're going to ignore sexual partners and only account for adverse outcomes experienced by the transfusion recipients and their future child, if pregnant. We will also simplify by ignoring cost and QALY discounting, as well as productivity loss due to illness or death. I've also inflated the probability of Guillain-Barre Syndrome so that we can get a stable solution while simulating a smaller number of transfusion recipients.

![](simulated_decision_tree_zika.png)

Model parameters are provided in an Excel file. This chunk reads in and displays the parameters. Note that some parameters are age specific. For a transfusion recipient whose age is X, their parameter would correspond to the row with the largest value in `age_lower` that is less than or equal to X. Parameters that do not vary by recipient age are entered only once and have 0 as the age_lower.

```{r}
t_params <- read_excel("params_assign3.xlsx", sheet="params")
t_params |>
  flextable() |>
  merge_v(j=c(1, 2, 3)) |> #Merge cells in first column with same value (group probabilities, costs, etc.)
  set_formatter(Value = label_comma()) |>
  theme_box() |> #Apply a theme for aesthetics
  autofit() #automatically set column widths to reasonable values
```

I've written this block of code for you. It puts the parameters into a named list `l_params` , you can access them by calling `l_params$PARAMETERNAME`. Note that parameters that depend on age are in the list as a tibble instead of as a single value.

```{r}
# Put parameters into named list l_params
params_freq_table <- table(t_params$rname)
l_params <- list()
for (param in names(params_freq_table)){
  if(params_freq_table[param]== 1){
    l_params[param]<-t_params[t_params$rname==param,]$value
  } else {
    l_params[[param]]<-tibble(
      "age_lower" = t_params[t_params$rname==param,]$age_lower,
      "value" = t_params[t_params$rname==param,]$value
    )
  }
}
```

## Sample cohort and baseline characteristics

In this code chunk, you should read in the file `transfusion_cohort.csv` and randomly sample 3,000 transfusion recipients. We also want to add a new column `age`, which assign an interger age to each transfusion recipient that is equally likely to be the age from the `age_group` column or any year up to four years older (e.g., if `age_group=45`, the recipient's age should be 45, 46, 47, 48, or 49 with equal probability (equivalent to adding a random integer between 0 and 4 to age_group).

```{r sample-recipients}
# Read in dataset
t_transfusion_cohort <- NA

# Sample 3,000 recipients (uncomment once t_transfusion_cohort loaded)
set.seed(500)
#t_sim_cohort <- sample_n(t_transfusion_cohort, 3000, replace = F)

# Assign their age (equally likely to be any integer age within age group)
# t_sim_cohort <- t_sim_cohort |>
#   mutate(age = NA)
```

### Baseline post-transfusion survival (done for you)

::: callout-note
## I have completed this section for Winter 2026, since the added discrete event simulation component below includes sampling other-cause mortality. You should only need to uncomment the code at the bottom of this section
:::

We want to simulate the recipients' baseline survival: the number of years they will live post-transfusion assuming no transfusion-transmitted infection. Since post-transfusion survival data based on age and component mix transfused were not available for the US, survival is estimated with what I call a "Frankenstein approach". The estimate combines 1-, 2-, 3-, 4-, and 5-year post-transfusion survival estimates from a US insurance claims analysis published in 2003 by Kleinman et. al., which is broken out only by 3 age groups, with multipliers derived from post-transfusion survival data from the SCANDAT database based on age and the number of red blood cell (RBC), platelet (PLT) and plasma (FFP) components transfused. The Kleinman US-based post-transfusion survival data are in an Excel sheet; well load those parameters as `t_US_survival`. The multipliers from SCANDAT are in another Excel sheet; we'll load those as `t_SCANDAT_mult`. We also include background other cause mortality based on a lifetable, which we'll read in as `t_ocm`.

```{r}
#Read in other cause mortality table and display first few rows
t_ocm <- read_excel("params_assign3.xlsx", sheet="other_cause_mortality") |>
  setDT()
t_ocm |> head() |> flextable()
#Read in SCANDAT mortality multiplier table and display first few rows
t_SCANDAT_mult <- read_excel("params_assign3.xlsx", sheet="SCANDAT_death_multipliers") |>
  setDT()
t_SCANDAT_mult |> head() |> flextable()
#Read in US post-transfusion survival data and display first few rows
t_US_survival <- read_excel("params_assign3.xlsx", sheet="US_posttransfusion_surv") |>
  setDT()
t_US_survival |> head() |> flextable()
```

Next, we need a function to sample each transfusion recipient's survival using our 'Frankenstein method'. For each recipient (row) in `t_sim_cohort`, the function should first create a vector of the probability of surviving to year `i`; then, it should randomly sample a baseline survival duration (survival without transfusion-transmitted Zika) from this distribution. Complete this function using the information in the comments.

NOTE: this function could probably be made more efficient using vectorization.

```{r}
#Takes t_sim_cohort and uBaseline, calculates remaining life years and QALYs assuming no transfusion-transmitted Zika and adds these as additional columns to t_sim_cohort
# INPUTS
# t_sim_cohort: table of a (simulated) cohort of individuals, with columns 
#.    units_rbc, units_plt, units_ffp, and age
# u_baseline: Baseline (without Zika) utility, from parameter list
get_survival <- function(t_sim_cohort, uBaseline){
    
  t_sim_cohort$survival <- 0
    
  for (row in 1:nrow(t_sim_cohort)){
    #Preallocate v_survProb, a vector with the recipient's cumulative 
    #. survival probability (e.g., probability of surviving to post-
    #. transfusion year X). The vector length should be 100 minus their 
    #. age at the time of transfusion
    recip_age <- t_sim_cohort[row,]$age
    v_survProb <- c(NA)
    length(v_survProb) <- 100 - recip_age
  
    #SURVIVING YEAR 0
    #. Tidyverse was slow and I switched it to
    #. data.table, so I'm providing all the year 1
    #. code for you.
    
    #from t_US_survival, get the probabiltiy of surviving to post-
    #. transfusion year 1 based on the age at transfusion
    p_surv_unadjusted <- t_US_survival[year_posttransfusion==0 & 
                                         age_lower <= recip_age,][
                                           age_lower==max(age_lower), value]
    
    #use t_ocm to calculate the probability they DON'T die from another cause
    p_survive_OCM <- 1 - t_ocm[age== recip_age, annual_prob_death]
    

    # Extract SCANDAT survival multiplier based on recipient's age 
    #. and units transfused
    survival_multiplier <- t_SCANDAT_mult[RBC_lower <= t_sim_cohort[row,]$units_rbc &
                                          PLT_lower <= t_sim_cohort[row,]$units_plt &
                                          FFP_lower <= t_sim_cohort[row,]$units_ffp &
                                          age_lower <= recip_age,][
                                            age_lower == max(age_lower) &
                                            RBC_lower == max(RBC_lower) &
                                            PLT_lower == max(PLT_lower) &
                                            FFP_lower == max(FFP_lower),
                                            multiplier]

    
    #Calculate probability recipient survives to 1 year post-transfusion
    #No need to edit
    v_survProb[[1]]<- p_surv_unadjusted + 
      survival_multiplier*(p_survive_OCM - p_surv_unadjusted)
    
    #Calculate cumulative probability of surviving post-transfusion years 2-5
    #. Applying same adjustment to years 2-5 of the US survival data as you
    #. just did for year 1.
    for (i in 2:5){
      recip_age <- recip_age+1
      p_survive_OCM <-  1 - t_ocm[age== recip_age, annual_prob_death] 
      p_surv_unadjusted <-  t_US_survival[year_posttransfusion==i-1 & 
                                         age_lower <= recip_age,][
                                           age_lower==max(age_lower), value]
      
      v_survProb[i] <- p_surv_unadjusted + 
        survival_multiplier*(p_survive_OCM - p_surv_unadjusted)
    }
    
    #Beyond post-transfusion year 5, cumulative survival is based only 
    #. on the annual probablity of other cause death
    for(i in 6:length(v_survProb)){
      recip_age <- recip_age+1
      p_survive_OCM <- 1 - t_ocm[age== recip_age, annual_prob_death]
      v_survProb[i] <- v_survProb[i-1]*p_survive_OCM
    }
    
    #sample recipeint's survival (number of post-transfusion years) and add as a 
    #. column to t_sim_cohort
    #. I provide the calculation for you;
    #. see if you can figure out why this works
    survival <- sum(1-v_survProb > runif(1))
    t_sim_cohort[row,]$survival <- survival
  }
  
  #Add a column named 'baseline_QALYs' to t_sim_cort, based on the survival and uBaseline
  t_sim_cohort <- t_sim_cohort |>
    mutate(baseline_QALYs = survival*uBaseline) #your code here
  
  return(t_sim_cohort)
}
```

Test it out: add survival to your cohort

```{r}
# # Uncomment and add the arguments
# t_sim_cohort <- get_survival(t_sim_cohort, uBaseline=l_params$uBaseline)
# 
# # Uncomment to take a look
# summary(t_sim_cohort$survival)
# summary(t_sim_cohort$baseline_QALYs)
```

### Pregnancy

We want to add two more columns: a variable `p_pregnant` containing the probability a recipient is pregnant based on their sex and age, and a binary variable called `isPregnant` where we simulate whether they are pregnant or not.

```{r}
getPregnant <- function(t_sim_cohort, #table with cohort we're simulating
                        l_params # our parameter list
                        ){
  
  #use l_params$p_recip_pregnant_by_age to get probability female
  #.  recipients are pregnant by age, assigning a probability
  #.  of 0 to male recipients
  #.  I did this for you
  setDT(t_sim_cohort)
  t_preg_by_age <- data.table(l_params$p_recip_pregnant_by_age)
  setnames(t_preg_by_age, 
           c("age_lower", "value"),
           c("age", "p_pregnant"))
  t_sim_cohort <- t_preg_by_age[t_sim_cohort, roll = Inf, on="age"]
  
  #overwrite with 0 if recipient is male
  t_sim_cohort[, p_pregnant:=ifelse(is_female==0,
                                    0,
                                    p_pregnant)]
  
  # Now we'll create a vector of ranom numbers the same length 
  #. as our recipients and use this to determine which 
  #. recipients are pregnant
  rand_pregnant <- NA
  t_sim_cohort <- t_sim_cohort |>
    mutate(isPregnant = NA)
  
  return(t_sim_cohort)
}
```

Now apply your function to add the pregnancy variables `t_sim_cohort` and take a look at them.

```{r}
# Uncomment and add the arguments

# t_sim_cohort <- getPregnant(NA)

# Uncomment to take a look
# summary(t_sim_cohort$p_pregnant)
# summary(t_sim_cohort$isPregnant)
```

## Outcomes of transfusion-transmitted Zika

We first simulate outcomes assuming that Zika transmitted to the transfusion recipient, using a series of functions that take `t_sim_cohort` as an input, calculate some outcomes, append these to the table, and return it.

This section uses data.table rolling joins. Here is a useful guide on them: <https://www.r-bloggers.com/2016/06/understanding-data-table-rolling-joins/>

```{r recipient-outcomes}
#Calculates recipient outcomes if transfusion-transmitted Zika occurs
recipient_outcomes_ttz <- function(t_sim_cohort, l_params){
  
  # Add age/sex-specific parameters to t_sim_cohort based on the
  #.  lookup tables stored in l_params
  setDT(t_sim_cohort) #The way I added uFlu male used data.table package's 
  #.  join, which is why I set the table to a data.table. Tidyverse methods were much slower
  
  #Get uFlu assuming recipient is male 
  t_uFluMale <- data.table(l_params$uFluMale)
  setnames(t_uFluMale, 
           c("age_lower", "value"),
           c("age", "uFluMale"))
  t_sim_cohort <- t_uFluMale[t_sim_cohort, roll = Inf, on="age"]
  
  #Extract uFlu assuming recipient is male 
  NA # your code here
  
  #add column uFlu (uFluFemale if is_female = 1; otherwise uFluMale)
  NA # your code here
  
  #Extract p_GBS_perm based on recipient's age
  t_GBS_perm <- data.table(l_params$p_GBS_perm)
  NA #your code here
  
  #Add columns to t_sim_cohort to track outcomes
  t_sim_cohort <- t_sim_cohort |>
    mutate(flulike=F,
               GBS=F,
               GBS_perm=F,
               GBS_death=F,
               cost_zika_symptoms=0,
               QALYs_zika_symptoms=0)
  
  # Simulate whether flu-like symptoms or Guillain-Barre syndrom occur
  #.  I coded this part for you
  rand_recip <- runif(nrow(t_sim_cohort))
  
  t_sim_cohort <- t_sim_cohort |>
    mutate(flulike = (rand_recip < l_params$p_flu_like_symptoms),
           GBS = (rand_recip > l_params$p_flu_like_symptoms & 
                    rand_recip <= l_params$p_flu_like_symptoms + l_params$p_GBS))
  
  # Simulate whether GBS was fatal or lead to permanent disability
  #.  based on the lookup table in l_params$p_GBS_perm if 
  #.  GBS==True (it should be 0 if GBS==F)
  #.  Then replace 0's in the mutate function with functions to simulate
  #.  whether permanent disability or death occur
  #.  remember: only recipients who experienced GBS can experience
  #.  permanent disability or death. You can achieve this
  #.  by multiplying your expression by GBS (0 for anyone without GBS).
  rand_GBS <- runif(nrow(t_sim_cohort))
  
  t_sim_cohort <- t_sim_cohort |>
    mutate(GBS_perm = GBS*(rand_GBS < p_GBS_perm), 
           GBS_death = F) #replace F with your code 
  
  
  # Calculate costs and QALYs
  #.  I've done some of this for you; complete by replacing 
  #.  NAs with code that works properly
  t_sim_cohort <- t_sim_cohort |>
    mutate(
      cost_zika_symptoms=case_when(
        GBS_death ~ NA,
        flulike ~ l_params$costFluR,
        GBS_perm ~ NA, #Note; l_params$costGBS_perm is per year of life remaining
        GBS ~ NA,
        T ~ 0), #otherwise no cost
      QALYs_zika_symptoms=case_when(
        GBS_death ~ 0,
        flulike ~ baseline_QALYs - (1-uFlu)*l_params$durationFlu/365,
        GBS_perm ~ NA, #experience uGBS for all remaining years
        GBS ~ NA, #experience uGBS for 1 year
        T ~ baseline_QALYs) #Otherwise same QALYs as baseline
    )
  return(t_sim_cohort)
  
}
```

Try this function on `t_sim_cohort`

```{r}
# t_sim_cohort <- recipient_outcomes_ttz(t_sim_cohort, l_params)
# str(t_sim_cohort)
```

We also need to simulate outcomes to the infant for any pregnant women transfused

```{r infant-outcomes}

infant_outcomes_ttz <- function(t_sim_cohort, l_params){
  
  # For pregnant recipients, simulate whether
  #. congenital zika syndrom occurs
  rand_CZS <- NA
  t_sim_cohort <- t_sim_cohort |>
    mutate(
      CZS = F
    )
  
  # For recipients whose infant contracted congenital
  #. zika syndrom, calculate their outcome
  rand_CZS_stillbirth <- NA
  t_sim_cohort <- t_sim_cohort |>
    mutate(
      CZS_stillbirth = F
    )
  
  # Add costs and infant_QALY_loss
  #. if CZS occurs, we incur a QALY toll
  #.  equivalent to the net present life expectancy of a newborn
  #.  regardless of whether CZS led to a stillbirth
  #.  or live birth with permanent disability
  #. (this is a pessimistic assumption but since
  #.  CZS is so rare it won't substantially impact
  #.  results)
  t_sim_cohort <- t_sim_cohort |>
    mutate(
      #If stillbirth: cost_CZS = costStillBirth - costDelivery 
      #.   (stillbirth cheaper than deliviery)
      #If CZS live birth: cost_CZS = costCZS_birth+costCZS_lifetime 
      cost_CZS = NA, 
      QALY_toll_CZS = -1*l_params$CZS_QALYloss*CZS
    )
  return(t_sim_cohort)
}
```

Try this function on `t_sim_cohort`

```{r}
# t_sim_cohort <- infant_outcomes_ttz(t_sim_cohort, l_params)
# str(t_sim_cohort)
```

## Policies & cost-effectiveness

We will now write a function to calculate blood center costs and the probability of transfusion-transmitted Zika with and without pathogen inactivation

```{r}
#This function calculates the probability
#. of transfusion transmitted Zika (no edits needed)
getProbZika <- function(probZika=0.0001, 
                        units_rbc, 
                        units_plt, 
                        units_ffp,
                        l_params){
  p_neg_unit = 1 - probZika
  return(
    1 - (
      (1-l_params$p_transmit_RBC*(1-p_neg_unit^units_rbc))*
        (1-l_params$p_transmit_PLT*(1-p_neg_unit^units_plt))*
        (1-l_params$p_transmit_FFP*(1-p_neg_unit^units_ffp))
    ))}


# This function calculates outcomes under each policy scenario
#.  (blood center costs, probability of transfusion-transmitted Zika,
#.  total cost & QALYs for "do nothing" and "pathogen inactivation" scenarios)
getPolOutcomes <- function(t_sim_cohort, l_params, prev=0.0001){
  # Replace all the NAs
  
  # DO NOTHIING SCENARIO
  #. calculate cost to blood center
  #. and each recipient's risk of transfusion-
  #. transmitted Zika
  t_sim_cohort <- t_sim_cohort |>
    mutate(
      cost_bloodCenter_doNothing = 0,
      p_TTZ_doNothing = NA)
  
  # PATHOGEN INACTIVATION
  #. calculate cost to blood center
  #. and each recipient's risk of transfusion-
  #. transmitted Zika
  #. costPathInact is per unit transfused (RBC+PLT+FFP)
  #. Calculate p_TTZ_pathInact using p_TTZ_doNothing and p_pathInact_prevent_TTZ
  t_sim_cohort <- t_sim_cohort |>
    mutate(
      cost_bloodCenter_pathInact = NA, 
      p_TTZ_pathInact = NA) 
  
  # Calculate total costs and QALYs under each scenario
  #. USE CONDITIONAL MONTE-CARLO
  #.  blood center costs are incurred no matter what
  #.  cost_CZS and cost_zika_symptoms are incurred only
  #.  when tansfusion-transmitted Zika (TTZ) occurs
  t_sim_cohort <- t_sim_cohort |>
    mutate(
      tot_cost_doNothing = NA,
      tot_cost_pathInact = NA,
      tot_QALYs_doNothing = NA,
      tot_QALYs_pathInact = NA
    )
}
```

Finally, use the functions above to run `t_sim_cohort` through the simulation. Calculate the incremental costs, incremental QALYs, and cost-effectiveness of pathogen inactivation for preventing transfusion-transmitted Zika.

```{r}
# COST-EFFECTIVENESS WITH ZIKA PREVALENCE OF 0.0001 (1 in 10,000 donations)

# Simulate t_sim_cohort
NA

# Calculate incremental cost
IC_pathInact_vs_doNothing <- NA
IC_pathInact_vs_doNothing

# Calculate incremental QALYs
IQ_pathInact_vs_doNothing <- NA
IQ_pathInact_vs_doNothing

# Calculate cost-effectiveness
ICER <- NA
ICER

# COST-EFFECTIVENESS WITH ZIKA PREVALENCE OF 0.01 (1 in 100 donations)

# Simulate t_sim_cohort

# Calculate incremental cost
IC_pathInact_vs_doNothing <- NA
IC_pathInact_vs_doNothing

# Calculate incremental QALYs
IQ_pathInact_vs_doNothing <- NA
IQ_pathInact_vs_doNothing

# Calculate cost-effectiveness
ICER <- NA
ICER
```

# B. Discrete event simulation

In this section, we will build a discrete event simulation model of "cancer-X" progression and screening in a cohort that begins at age 20. The overall modelling approach is based on the DES tutorial by Lopez-Mendez et. al. (2021) available at <https://www.medrxiv.org/content/10.1101/2025.05.15.25327635v2>, as summarized by the schematic below (reproduced from their Figure S1):

[![Figure S1 from Lopze-Mendex et. al. 2021](DEStut%20figS1.png)](https://www.medrxiv.org/content/10.1101/2025.05.15.25327635v2)

## Setup

Here we specify the number of individuals to simulate, and create a baseline data table (all individuals and their characteristics at time 0). We are simulating a cohort at `age_start = 20`, half female.

Our table includes tracking variables for precancers, cancers, and screening tests they have undergone. We assume no one has developed a precancer or cancer before age 20, so all three should be 0 at the start of the simulation.

```{r}

# number to simulate

# Simulate 20,000 individuals in the final version you submit
n_sim <- 20000 

# For computational efficiency, you may start by simulate fewer individuals, e.g. 2,000, while developing code, but comment out before submitting
# n_sim <- 2000

# Define vector of event names
v_states <- c("healthy",
              "precancer_UD", "precancer_Detect", 
              "cancer_UD", "cancer_Tx",
              "cancerDeath", "OCM") # OCM refers to other cause mortality
v_states <- factor(v_states, levels = v_states)

# create baseline data.table (no edits needed)
dt_baseline <- data.table(
  id = 1:n_sim,                        # unique identifier for each individual
  sexFemale = rep(c(0,1), each=n_sim/2), # sex
  age_start = 20,                           # age (all 20 at start)
  from = factor("healthy", levels=v_states), # current state (all healthy at start)
  to = factor(NA, levels=v_states), # next state (unknown at start)
  T_start = 0,                      # time entered the current state
  T_end = as.numeric(NA),           # time exited the current state
  dwell_time = as.numeric(NA),      # time spent in the current state
  n_precancers = 0,                 # number of prior precancers (0 at start)
  n_cancers = 0,                # number of prior cancers (0 at start
  n_screens = 0                 # times screened up until current time (0 at start)
)

# Inspect it
str(dt_baseline)

```

### Other cause mortality

The time until other cause mortality (OCM), when they will die if they do not die from cancer X earlier, is assumed to be independent of their trajectory with regards to cancer X. We can therefore sample OCM for each individual just once, at the start of the simulation. We will use age-specific probabilities of death from Statistics Canada for the year 2020 to compute the probability of other-cause death in all years from an individuals' current age until 110.

We will do so by sampling year of OCM from a probability mass function (PMF) derived from the age-specific probabilities of death. Whereas the life table probability containst he probability of dying in a given year, conditional on surviving to that age, the PMF for an individual gives the probability of dying in each future year. We will derive the PMF from the life table through the following steps:

1.  Read in age-specific probabilities of death

    -   Each row contains the conditional probability of dying between age $x$ and age $x+1$, i.e. $P(\text{die before } t=x+1 \mid \text{alive at }t=x)$

2.  Derive a cumulative distribution function (CDF) of death by age from the life table

    -   CDF gives $P(\text{die before } t=x \mid \text{alive at }t=0)$

    -   For age 0, CDF is simply the probability of death in that year

    -   For age $i>0$, the CDF can be computed iteratively as:

$$
  CDF(i) = CDF(i-1) + P(\text{die before } t=i \mid \text{alive at }t=i-1) \times (1 - CDF(i-1))
  $$

3.  Compute the probability mass function (PMF) from the CDF by taking the difference between CDF values in consecutive years

    -   Each row of the PMF should contain $P(\text{die between } t=x \text{ and } x+1 \mid \text{alive at }t=0)$

    -   If we were simulating a cohort at starting age 0, we could sample the year of death from the PMF with these probabilities

4.  Within the function `f_compute_OCM()`, we will:

    -   Truncate the PMF so that it starts at an individual's current age (throwing out entries for years the individual has already lived)

    -   Re-normalize the PMF so that the probabilities sum to 100%

    -   Sample the age of death from the truncated PMF

`f_compute_OCM()` takes a data.table (like `dt.baseline` created above) which might contain individuals with different ages. If so, it will identify the unique starting ages, compute the age-specific truncated PMF for each one, and then sampling OCM for all individuals who start at that age in a batch. .

```{r}

# Read in life table from Statistics Canada
dt_OCM_by_age <- fread("prob_death_by_age_2020_StatsCan.csv")
str(dt_OCM_by_age)


# COMPUTE CDF AND PMF FOR INDIVIDUALS STARTING AT AGE 0

# Add column CDF_death (probability of dying by the end of age i)
#. For age 0, CDF_death is prob_death in that year
dt_OCM_by_age[Age==0, 
              CDF_death := prob_death] # To start, use the age 0 life table probability

#. Must loop through ages 1 to max age (110) to compute CDF_death.
#.  For age i, CDF_death = CDF_death(i-1) + prob_death(i)*(1-CDF_death(i-1))
for (age in 1:max(dt_OCM_by_age$Age)){
  # CDF for previous age (e.g., age 0 when computing for age 1)
  cdf_prev_age <- dt_OCM_by_age[Age==age-1, CDF_death]
  # Compute CDF_death for current age
  dt_OCM_by_age[Age==age,
                CDF_death := NA] # EDIT THIS
}

# Compute PMF from CDF by differencing
dt_OCM_by_age[, PMF := CDF_death - shift(CDF_death, n=1, fill=0)]

# check that PMF sums to 1
sum(dt_OCM_by_age$PMF) # check that it sums to 1

# Function to sample OCM times for all individuals in dt_baseline
#. Uses col "age_start" from dt_baseline and dt_OCM_by_age
#. to create a new table T_OCM with sampled OCM times and ages
f_compute_OCM <- function(dt, dt_OCM_by_age){
  # For each unique starting age, will sample time to OCM in a batch
  start_ages <- unique(dt$age_start)
  max_age <- 0 # EDIT THIS
  
  # first_start_age should be T for first iteration of loop and F thereafter
  #. its used to trigger initializing dt_OCM on the first loop and
  #.  rbind to it thereafter
  first_start_age <- T
  
  for(start_age in start_ages){
    
    # Construct age-specific PMF by subsetting the overall PMF and
    #. normalizing so probabilities sum to 100%
    probs_unnormalized <- dt_OCM_by_age[Age >= start_age,PMF,] # subset
    
    # Normalize: rescale probabilities in the truncated PMF to sum to 1
    probs <- probs_unnormalized # EDIT THIS
    
    # Subset dt_baseline to individuals starting at start_age
    dt_subset <-dt[age_start==start_age]
    
    # Sample INTEGER time to OCM for all individuals with replacement
    dt_subset[, age_OCM := 0] # EDIT THIS
    
    # Edit T_OCM to add uniform noise per year
    dt_subset[, age_OCM := age_OCM + runif(.N)] 
    
    # Combine dt_subset back into dt_OCM
    if(first_start_age){
      dt_OCM <- dt_subset
    } else{
      dt_OCM <- rbind(dt_OCM, dt_subset)
    }
    
    first_start_age <- F # set to F after first iteration
  }
  # Compute T_end, the simulation time of OCM, as age_OCM - age_start
  dt_OCM[, T_end := age_OCM - age_start] 
  return(dt_OCM[, c("id", "age_start", "age_OCM", "T_end")])
}
```

**Test your function**

In this code chunk, we will construct `dt_baseline_test` with individuals of different starting ages to test the `f_compute_OCM()` function. We will plot histograms of the sampled age at OCM and time to OCM, faceted by starting age, to check whether the function seems to be working properly.

Once you're confident the function is working, you can apply it to `dt_baseline` to sample OCM times for the full cohort starting at age 20.

```{r}
# Use the f_compute_OCM function in test dt_baseline with various ages

# Construct a version of dt_baseline with different starting ages to test your function
dt_baseline_test <- data.table(
  id = 1:(5*500),
  age_start = rep(seq(0, 100, by=25), each=500)
)

set.seed(50)
dt_OCM_test <- f_compute_OCM(dt_baseline_test, dt_OCM_by_age)

ggplot(data = dt_OCM_test, aes(x=age_OCM, fill = as.factor(age_start))) +
  scale_x_continuous(breaks = seq(0, 110, by=10))+
  geom_histogram(binwidth = 3)+
  facet_grid(rows = vars(age_start))+
  ggtitle("Simulated age of OCM by starting age")+
  theme(legend.position = "none")

ggplot(data = dt_OCM_test, aes(x=T_end, fill = as.factor(age_start))) +
  scale_x_continuous(breaks = seq(0, 110, by=10))+
  geom_histogram(binwidth = 3)+
  facet_grid(rows = vars(age_start))+
  ggtitle("Time from simulation start to OCM by starting age")+
  theme(legend.position = "none")
```

Which group lives to a longer age on average, individuals starting at age 25 or age 75? Why is this the case?

> Replace this text with your answer

**Apply your function to full cohort**

```{r}
# Use function to compute OCM times for all individuals in dt_baseline 
#.  everyone starts at age 20

dt_OCM <- f_compute_OCM(dt_baseline, dt_OCM_by_age)

ggplot(data = dt_OCM, aes(x=T_end)) +
  scale_x_continuous(breaks = seq(0, 110, by=10))+
  geom_histogram(binwidth = 3)+
  ggtitle("Time from simulation start to OCM for cohort (starting age 20)")+
  theme(legend.position = "none")

ggplot(data = dt_OCM, aes(x=age_OCM)) +
  scale_x_continuous(breaks = seq(0, 110, by=10))+
  geom_histogram(binwidth = 3)+
  ggtitle("Age at time of OCM")+
  theme(legend.position = "none")

```

### Events (transitions) allowed

Instead of using an adjacency matrix $A$ to define possible events based on an individual's current state (like the Lopez-Mendez et. al. tutorial), we use a list `ls_transitions_NS` for events that can happen without screening (NS stands for "no screening"). `ls_transitions_NS` is a named list of vectors: the names correspond to the "from" state and the entries correspond to the "to" states for possible transitions (states that can be directly entered from the "from" state). For example, from the "healthy" state, an individual can transition to either the "precancer_UD" state or the "OCM" state.

Allowable transitions are as follows:

-   Healthy individuals can develop undetected precancers or die from other causes

-   Individuals with undetected precancers can progress to undetected cancer or die from other causes

-   Individuals with undetected cancer can either begin treatment, die from cancer, or die from other causes

-   Individuals undergoing cancer treatment can either die from cancer, return to healthy, or die from other causes

Absorbing states (`cancerDeath`, `OCM`) are not included in the list.

```{r}
ls_transitions_NS <- list(
  "healthy" = c("precancer_UD", "OCM"), #completed for you; fill in the rest
  "precancer_UD" = c(),
  "cancer_UD" = c(),
  "cancer_Tx" = c()
)
```

**Screening events**

We will also simulate a strategy where individuals undergo cancer screening at deterministic times, based on their age. For this, we define another list `ls_transitions_screening` that describes the transitions that occur when an individual is screened which depend on their current state. For simplicity, we assume perfect compliance with screening intervals, a perfect screening test, and that all detected precancers are immediately and completely removed, returning the individual to healthy. Therefore, transitions that occur when an individual is screened are:

-   **Healthy individuals** remain healthy

-   **Individuals with undetected precancers** have their precancers detected and removed, returning to healthy

-   **Individuals with undetected cancer** have their cancer detected and immediately begin treatment.

Individuals in cancer treatment are not screened.

[**Suggestion:**]{.underline} It may be useful to draw a state transition diagram to visualize model structure.

[**Note:**]{.underline} This model puts individuals back into the screened population after they are treated for cancer. Note that in the real world, monitoring for recurrence after cancer is usually called surveillance, not screening. Surveillance usually involves more frequent monitoring than screening due to the high risk of recurrent cancer.

```{r}
ls_transitions_screening <- list(
  "healthy" = c("healthy"), #completed for you; fill in the rest
  "precancer_UD" = c(),
  "cancer_UD" = c()
)
```

### Sample latent dwell times

We define a function `f_sample_latent_events` to compute all randomly sampled dwell times using parameters in a list `prms`. We exclude transitions to other cause mortality (because we already sampled that above). We also omit screening-related transitions, which we will handle separately because time-to-screening is prespecified, and transitions that occur based on screening are deterministic based on your current state.

The specific distributions are given in the comments below. Note: For a homogeneous poisson process with exponentially distributed dwell times with a base rate `base_rate` and hazard ratios `hr`, the adjusted rate is `base_rate * (hr ^ covariate_value)` under proportional hazards assumptions.

```{r}

# Define parameters for sampling latent dwell times (no edits needed to prms)
prms <- list(
  healthy_to_precancerUD = list(
    # WEIBULL distribution
    shape = 2,
    scale = 70),
  
  precancerUD_to_cancerUD = list(
    # EXPONENTIAL with proportional hazards on number of previous precancers
    base_rate = 1/6,
    hr_per_prior_precancer = 3),
  
  cancerUD_to_cancerDeath = list(
    # EXPONENTIAL with proportional hazards by age, previous cancers
    base_rate = 1/9,
    hr_per_prior_cancer = 3,
    hr_age_60plus = 2),
  
  cancerUD_to_cancerTx = list(
    # EXPONENTIAL with proportional hazards by age, previous cancers
    base_rate = 1/3,
    hr_per_prior_cancer = 4,
    hr_age_60plus = 1.5),
  
  cancerTx_to_healthy = list(
    # FIXED at 2 years
    fixed_time = 2),
  
  cancerTx_to_cancerDeath = list(
    # EXPONENTIAL with proportional hazards by age, previous cancers
    base_rate = 1/25,
    hr_per_prior_cancer = 3,
    hr_age_60plus = 2)
)

# Function to sample latent event times for all possible transitions
# from a given from_state
# INPUTS: 
#. @param dt
#.    data.table with columns id, from, to, T_start, age_start 
#.          (dt_subset in f_advance_DES below)
#. @param from_state
#.    character string with name of current state
#. OUTPUT:
#.  @return updated dt with sampled dwell_time and T_end for each possible transition
#.        from from_state
f_sample_latent_events <- function(dt, from_state){
  # COMPUTE ALL TRANSITONS SAMPLED FROM DISTRIBUTIONS
  if(from_state=="healthy"){
    # healthy -> precancer_UD
    # WEIBULL Distributed 
    #. (completed for you)
    dt[to == "precancer_UD",
     dwell_time := rweibull(.N, 
                            shape=prms$healthy_to_precancerUD$shape,
                            scale=prms$healthy_to_precancerUD$scale)]
  } else if(from_state == "precancer_UD"){
    # precancer_UD -> cancer_UD
    # EXPONENTIAL with proportional hazards on number of previous precancers
    #. (completed for you)
    dt[to == "cancer_UD",
       dwell_time := rexp(.N, 
                          rate = prms$precancerUD_to_cancerUD$base_rate *
                            (prms$precancerUD_to_cancerUD$hr_per_prior_precancer ^ n_precancers))]
  } else if(from_state == "cancer_UD"){
    # cancer_UD -> cancerDeath
    # EXPONENTIAL with proportional hazards by age, previous cancers
    #. (completed for you)
    dt[to == "cancerDeath",
       dwell_time := rexp(.N, rate = 
         prms$cancerUD_to_cancerDeath$base_rate *
         (prms$cancerUD_to_cancerDeath$hr_per_prior_cancer ^ pmax(0,n_cancers-1))*
         fifelse(age_start + T_start >= 60,
                 prms$cancerUD_to_cancerDeath$hr_age_60plus,
                 1))]
    
    # cancer_UD -> cancerTx
    # EXPONENTIAL with proportional hazards by age, previous cancers
    #. (must be corrected)
    dt[to == "cancer_Tx",
       dwell_time := rexp(.N, rate = 1 # correct me using variables in prms
         )]
    
  } else if(from_state == "cancer_Tx"){
    # cancerTx -> healthy
    # FIXED duration
    dt[to == "healthy",
       dwell_time := 1 # correct me using variables in prms
       ]
    
    # cancerTx -> cancerDeath
    # EXPONENTIAL with proportional hazards by age, previous cancers
    dt[to == "cancerDeath",
       dwell_time := rexp(.N, rate = 1 # correct me using variables in prms
         )]
  }
  
  # Compute T_end based on the dwell time and T_start
  dt[, T_end := NA] # edit this
  
  return(dt)
}

```

**Test your function**

This code chunk lets you check if your `f_sample_latent_events()` function works as expected by sampling latent event times from various starting states and plotting the results.

Note: This code chunk should run without any edits as long as ls_transitions_NS and f_sample_latent_events() are correctly specified above. You will need to switch it from `eval: false` to `eval: true`.

```{r}
#| eval: false #Switch to eval: true when ready

#########################################################
###    FROM HEALTHY    ##################################
#########################################################
dt_test <- copy(dt_baseline)
current_state <- "healthy"
events_allowed <- ls_transitions_NS[[current_state]]


# Expand dt_test to have one row for each possible transition for each ID
id <- unique(dt_test$id) # unique IDs in FROM state
setkey(dt_test, id)
## CJ is more efficient version of expand.grid  for data.tables
dt_subset_long   <- merge(dt_test[,!c("to")],
                          CJ(id, "to"=factor(events_allowed, levels = v_states)), 
                          all.x = F)
    
# Sample latent next event times for each individual for each possible event
dt_subset_long <- f_sample_latent_events(dt_subset_long, from_state = current_state)

# Inspect sampled times
ggplot(data = dt_subset_long[!is.na(dwell_time)], aes(x=dwell_time)) +
  geom_histogram(binwidth = 3)+
  facet_grid(rows = vars(to))+
  ggtitle("Sampled dwell times from healthy")


#########################################################
###    FROM PRECANCER UNDETECTED    #####################
#########################################################
dt_test <- copy(dt_baseline)
current_state <- "precancer_UD"
dt_test[, from := factor(current_state, levels = v_states)]
events_allowed <- ls_transitions_NS[[current_state]]

# Expand dt_test to have one row for each possible transition for each ID
id <- unique(dt_test$id) # unique IDs in FROM state
setkey(dt_test, id)
## CJ is more efficient version of expand.grid  for data.tables
dt_subset_long   <- merge(dt_test[,!c("to")],
                          CJ(id, "to"=factor(events_allowed, levels = v_states)), 
                          all.x = F)
    
# Sample latent next event times for each individual for each possible event
dt_subset_long <- f_sample_latent_events(dt_subset_long, from_state = current_state)

# Inspect sampled times
ggplot(data = dt_subset_long[!is.na(dwell_time)], aes(x=dwell_time)) +
  geom_histogram(binwidth = 3)+
  facet_grid(rows = vars(to))+
  ggtitle("Sampled dwell times from precancer UD")


#########################################################
###    FROM CANCER UNDETECTED    ########################
#########################################################
dt_test <- copy(dt_baseline)
current_state <- "cancer_UD"
dt_test[, from := factor(current_state, levels = v_states)]
events_allowed <- ls_transitions_NS[[current_state]]

# Expand dt_subset to have one row for each possible transition for each ID
id <- unique(dt_test$id) # unique IDs in FROM state
setkey(dt_test, id)
## CJ is more efficient version of expand.grid  for data.tables
dt_subset_long   <- merge(dt_test[,!c("to")],
                          CJ(id, "to"=factor(events_allowed, levels = v_states)), 
                          all.x = F)
    
# Sample latent next event times for each individual for each possible event
dt_subset_long <- f_sample_latent_events(dt_subset_long, from_state = current_state)

# Inspect sampled times
ggplot(data = dt_subset_long[!is.na(dwell_time)], aes(x=dwell_time)) +
  geom_histogram(binwidth = 3)+
  facet_grid(rows = vars(to))+
  ggtitle("Sampled dwell times from cancer UD")


#########################################################
###    FROM CANCER TREATED    ###########################
#########################################################
dt_test <- copy(dt_baseline)
current_state <- "cancer_Tx"
dt_test[, from := factor(current_state, levels = v_states)]
events_allowed <- ls_transitions_NS[[current_state]]

# Expand dt_subset to have one row for each possible transition for each ID
id <- unique(dt_test$id) # unique IDs in FROM state
setkey(dt_test, id)
## CJ is more efficient version of expand.grid  for data.tables
dt_subset_long   <- merge(dt_test[,!c("to")],
                          CJ(id, "to"=factor(events_allowed, levels = v_states)), 
                          all.x = F)
    
# Sample latent next event times for each individual for each possible event
dt_subset_long <- f_sample_latent_events(dt_subset_long, from_state = current_state)

# Inspect sampled times
ggplot(data = dt_subset_long[!is.na(dwell_time)], aes(x=dwell_time)) +
  geom_histogram(binwidth = 3)+
  facet_grid(rows = vars(to))+
  ggtitle("Sampled dwell times from cancer treated")

```

### Function for advancing the DES

This chunk contains the function `f_advance_DES()`, which advances the discrete event simulation by one event for all individuals in the table `dt_next_event`, a table that should include all individuals who have not yet reached a terminal state (death). It is designed to be called repeatedly until no more individuals remain alive (until `nrows(dt_next_event)=0`). The function performs the following steps:

-   Determine all possible transitions for each individual based on their current state
-   Identify a latent time-to-event `T_end` for each possible event by:
    -   Using `f_sample_latent_events()` above to sample dwell times from cancer progression in absence of screening
    -   Using `dt_OCM`, created above, to identify the time until other cause death
    -   (**If screening ages is provided)** Use vector `screen_ages` to set `T_end` for next screening date and set the transition based on `ls_transitions_screening` (if the individual is younger than `max(screen_ages)` and in screening applies to the individual's current state).
-   Identify which of the latent events will be the next event for each individual (event with the minimum `T_end`)
-   Simulate the event happening and advance the model:
    -   Update each individual's state, time, and tracking variables in `dt_this_event`
    -   Save the transitions from this advance in `dt_history` (data.table stored as a global variable) with updated counts for precancers, cancers, and screens.
    -   Prepare a new `dt_next_event` based on `dt_this_event`
        -   Remove individuals in terminal states (dead)
        -   Update `from` and `t_start`; clear `t_end` and `to`

The function returns a new `dt_next_event`, where individuals have all moved forward one event and those who have died have been removed. Later, when running the simulation, you'll run the function repeatedly until it returns an empty `dt_next_event`.

```{r}

# function to advance the DES by one event for all individuals
f_advance_DES <- function(
    dt_next_event, # data.table with each individual's current state & time
    ls_transitions_NS, # list of allowed transitions by FROM state
    dt_OCM, # data.table with pre-sampled OCM times
    screen_ages = c() #empty vector if no screening
    ){
  
  # Determine unique current ("from") states, no edits
  v_current_states <- unique(dt_next_event$from)

  # Make empty dt to store each individual's state after this event, no edits
  dt_this_event <- data.table()
  
  # For each current state (FROM) in dt_main:
  for( i in 1:length(v_current_states)){
    
    # SAMPLE NEXT EVENT TIMES FOR EACH INVIVIDUAL
    
    # Create dt_subset with individuals in FROM state, no edits
    dt_subset <- dt_next_event[from == v_current_states[i], ]
    
    # Get the current state & allowed events/transitions from that state
    current_state <- NA # CORRECT THIS
    events_allowed <- NA # CORRECT THIS
    
    # Expand dt_subset to have one row for each possible transition for each ID
    
    NA # Your code needed
    
    # Sample latent next event times for each individual for each possible event
    
    NA # Your code needed
    
    # Add OCM times (if OCM is an allowed event)
    if ("OCM" %in% events_allowed){
      # Add OCM times from dt_OCM (no edits needed)
      setkey(dt_OCM, id)
      dt_subset_long[to=="OCM",T_end := dt_OCM[.SD, T_end, on="id"]]
    }
    
    # Add screening events 
    #. (if applicable to current state AND screen_ages supplied to function)
    if (length(screen_ages)>0 &
       (current_state %in% names(ls_transitions_screening))  ){
      # Note: you can run "no screening" scenario" before completing this if statement
      
      # Determine which transition will happen if screened in current state
      transition_if_screened <- NA # your code needed
      
      #add current age to dt_subset
      dt_subset[, age := age_start+T_start ]

      # Create dt_subset_screen containing only individuals who have not yet
      #.  aged out of screening
      dt_subset_screen <- dt_subset[age < max(screen_ages), ]
      
            # Only continue constructing time-to-screening if at least one individual is young enough for screening
      if (nrow(dt_subset_screen) > 0){
        # Determine next screening age for each individual in dt_subset_screen
        #. (smallest value in next_screen_age that exceeds age
        #  add next_screen_age as a new column. (no edit needed)
        dt_subset_screen[, next_screen_age := sapply(age, 
              function(x) min(screen_ages[screen_ages > x]))]
        
        # Add the transition that will occur (when the individual 
        #. reaches next_screen_age)
        
        # Compute T_end, the time to the next screen, based on age
        dt_subset_screen[, T_end := NA ] # EDIT THIS
        
        # Fill in "to" with the state that will be entered if screened
        dt_subset_screen[, to := NA] # EDIT THIS
                    
        #. increment "n_screens" by 1
        dt_subset_screen[, n_screens := n_screens + 1]
        
        # Combine dt_subset_screen (without next_screen_age or age column) back into dt_subset_long
        #. no edit needed
        dt_subset_long <- rbind(dt_subset_long, 
                                dt_subset_screen[, !c("next_screen_age", "age")],
                                use.names = T)
      }
    }
    
    # DETERMINE NEXT EVENT FOR EACH INDIVIDUAL
    # only keep row with min T_end for each individual (no edit needed)
    dt_subset <- dt_subset_long[, .SD[which.min(T_end)], by = id]
    
    # Combine dt_subset back into dt_main (no edit needed)
    dt_this_event <- rbind(dt_this_event,dt_subset,
                           use.names = T)
  
  } #end loop through current states
  
  ## UPDATE dt_history and dt_next_event BASED ON dt_this_event
  
  # Update n_precancers and n_cancers
  dt_this_event[to=="precancer_UD", n_precancers := NA] # EDIT THIS
  dt_this_event[to=="cancer_UD", n_cancers := NA] # EDIT THIS
  
  # Save history (include transitions and time-varying covariates)
  #.  "<<-" operator modifies dt_history in global
  #.  environment, outside function scope (no edit needed)
  dt_history <<- rbind(dt_history, 
                       dt_this_event[, .(id, from, to, T_start, T_end,
                                         n_precancers, n_cancers, n_screens)],
                       use.names = T)
  
  # Remove dead individuals from dt_this_event t
  dt_this_event <- dt_this_event # EDIT THIS

  # Overwrite dt_next_event with dt_this_event
  # and prepare columns for the next iteration (no edit needed)
  dt_next_event <- copy(dt_this_event)
  
  #.   From state becomes To state; to state is NA (no edit needed)
  dt_next_event[, from := to]
  dt_next_event[, to := NA]
  #.   T_start becomes T_end; T_end and dwell_time are NA (no edit needed)
  dt_next_event[, T_start := T_end]
  dt_next_event[, T_end := NA]
  dt_next_event[, dwell_time := NA]
  
  return(dt_next_event)
}

```

## Policy simulation

### Run "no screening" strategy

We will run the simulation without screening. To do so, we will repeatedly calling `f_advance_DES()` until all individuals have reached absorbing states (death). We will store the full history of events in `dt_history_NS` for later analysis.

```{r}

# Initialize dt_next_event as copy of dt_baseline (no edit needed)
dt_next_event = copy(dt_baseline)

# Create or reset dt_history, a global variable that is updated from 
#. within f_advance_DES() function (no edit needed)
dt_history = data.table()

set.seed(20)

#. Run the DES until all individuals have reached absorbing states
#. i.e., until dt_next_event is empty
while (FALSE){ # edit while loop condition and function arguments
  dt_next_event <- f_advance_DES(
    dt_next_event = NA,
    ls_transitions_NS = NA,
    dt_OCM = NA
    )
}

#Copy dt_history to dt_history_NS for later analysis
#. (we will overwrite dt_history when simulating other strategies)
dt_history_NS <- copy(dt_history) # no edit needed

```

### Run "screening" strategy

Next, we'll simulate the "screening" strategy where individuals are screened at ages 50, 60, and 70. We'll again repeatedly call `f_advance_DES()`, this time supplying the vector `screen_ages` to the function.. The full history of events will be stored in `dt_history_screen` for later analysis.

```{r}

# Initialize dt_next_event as copy of dt_baseline (no edit needed)
dt_next_event = copy(dt_baseline)

# Create or reset dt_history, a global variable that is updated from 
#. within f_advance_DES() function (no edit needed)
dt_history = data.table()

set.seed(20)

#. Run the DES until all individuals have reached absorbing states
#. i.e., until dt_next_event is empty 
while (FALSE){ # edit while loop condition and function arguments)
  dt_next_event <- f_advance_DES(
    dt_next_event = NA,
    ls_transitions_NS = NA,
    dt_OCM = NA,
    screen_ages = NA #screen at ages 50, 60, 70 (sim time 30, 40, 50)
    )
}

#Copy dt_history to dt_history_screen for later analysis
dt_history_screen <- copy(dt_history) # no edit needed

```

### Analyze simulation output

To analyze the results of the two strategies, we will combine `dt_history_NS` and `dt_history_screen` into a data.table called `dt_hist_all`, which we will use to compare the following outcomes:

-   Life years experienced

-   Cumulative number of cancers, precancers, and screening events

-   Number of individuals occupying each state over time.

#### Life-years gained by screening program

Set this chunk to `eval: true` once you have created `dt_history_NS` and `dt_history_screen` above.

```{r}
#| eval: false  # change to eval: true when ready
# Combine dt_history_NS and dt_history_screen with an indicator for strategy
dt_hist_all <- rbind( # no edits needed
  dt_history_NS[, strategy := "no_screening"],
  dt_history_screen[, strategy := "screening"],
  use.names = T
)

# Compute per-person average time in each state by strategy
dt_hist_all_summary <- dt_hist_all[, .( # no edits needed
  avg_time_in_state = sum(T_end - T_start)/n_sim
), by=.(strategy, from)]

# View the summary table
dt_hist_all_summary

# Compute average per-person life years gained by screeening vs. no screening

avg_LY_gained <- NA #edit

avg_LY_gained # print variable for grading

```

#### Cumulative number of cancers, precancers, and screenings performed

Set this chunk to `eval: true` once you have created `dt_history_NS` and `dt_history_screen` above.

No edits are needed for this section, just take a look at my code below and try to understand the logic.

```{r}
#| eval: false  # change to eval: true when ready

# Cumulative n_cancers, n_precancers, n_screens over time by strategy

# Melt dt_hist_all to get the cumulative number of events by id, strategy, T_end
dt_cum_event_by_id <- melt(
  dt_hist_all,
  id.vars = c("id", "strategy", "T_end"),
  measure.vars = c("n_cancers", "n_precancers", "n_screens"),
  variable.name = "variable",
  value.name = "cumTotal"
)

# Keep only rows with cumTotal > 0 
# Keep only the first row (min T_end) for each strategy, id, variable, cumTotal
dt_cum_event_by_id <- dt_cum_event_by_id[cumTotal > 0, ]
dt_cum_event_by_id <- dt_cum_event_by_id[,
                                               .SD[which.min(T_end)],
                                               by=.(strategy, id, variable, cumTotal)]


# Rename T_end to time
setnames(dt_cum_event_by_id, "T_end", "time")

dt_cum_event_by_id[, var_increased := fifelse(cumTotal==0, 0, 1)]

# count the rows of dt_cum_event_by_id by variable & strategy up to time
#. to get the cumulative number of events occuring by time
dt_cum_event <- dt_cum_event_by_id[order(time), cumcount := cumsum(var_increased),
        by = .(strategy, variable)]

# Divide by n_sum to get the average per individual
dt_cum_event[, avg_value := cumcount / n_sim]

# Remove unnecessary columns
dt_cum_event[, c("id", "cumTotal", "var_increased", "cumcount") := NULL]

# Create baseline rows for time 0 with avg_value = 0
dt_cum_event_bl <- CJ(
  strategy = c("no_screening", "screening"),
  variable = c("n_cancers", "n_precancers", "n_screens"),
  time = 0,
  avg_value = 0
)

# Combine baseline rows with dt_cum_event
dt_cum_event <- rbind(
  dt_cum_event_bl,
  dt_cum_event,
  use.names = T
)

# Add rows for all variable/strategy combinations
#. That have the max_value at time max_time

# Get maximum average value by strategy and variable
dt_cum_event_max <- dt_cum_event[, .(
  avg_value = max(avg_value)
), by=.(strategy, variable)]

# Get maximum time in dt_cum_event &
#. add it to dt_cum_event_max
max_time <- dt_cum_event[, max(time)]
dt_cum_event_max[, time := max_time]

# Combine event_max rows with dt_cum_event
dt_cum_event <- rbind(
  dt_cum_event,
  dt_cum_event_max,
  use.names = T
)

# Plot it
ggplot(data = dt_cum_event, aes(x=time, y=avg_value, color = strategy))+
  geom_line()+
  facet_grid(rows = vars(variable), scales = "free_y")+
  ylab("Average cumulative events per individual")+
  xlab("Time since start of simulation (years)")

```

#### State occupancy over time by strategy

We will analyze `dt_hist` to compute the number of people in each state over time. The state occupancy changes anytime someone enters or leaves a state.

Set this chunk to `eval: true` once you have created `dt_history_NS` and `dt_history_screen` above.

```{r}
#| eval: false  # change to eval: true when ready
 
# create empty data.table dt_state_occupancy
dt_state_occupancy <- data.table()

# For each state & each strategy, compute the number of occupants over time
for (strat in unique(dt_hist_all$strategy)){
  
  # Subset dt_history to current strategy
  dt_history_thisStrat <- NA #edit this
  
  # Remove rows where from==to (no state change; occurs if screened when healthy)
  dt_history_thisStrat <- NA #edit this
  
  # Loop over states
  for (state in v_states){
    
    # Will add two columns to dt_history_NS_strat, one for arrivals into state
    #. and another for departures from state, then create dt_state_trace.
    #. if statement used because absorbing states have different logic than non-absorbing states.
    if (state %in% c("OCM", "cancerDeath")){
      
      # Absorbing states have no departures.
      
      # Arrivals to state occur at T_end when "to" == state
      dt_history_thisStrat[ , arr_at_T_end := NA] # edit this
      
      # Create dt_state_trace with time = T_end and change +1 for arrivals into
      #.  this (absorbing) state
      dt_state_trace <- dt_history_thisStrat[, .(time = T_end, change = arr_at_T_end)]
      
    } else {
      # Non-absorbing states have both arrivals and departures.
      
      # Arrivals to state occur at T_start when "from" == state
      dt_history_thisStrat[ , arr_at_T_start := NA] # edit this
      # Departures from state occur at T_end when "from" == state
      dt_history_thisStrat[ , dep_at_T_end := NA] # edit this
      
      # Create dt_state_trace with all arrival and departure events
      dt_state_trace <- rbind(
        dt_history_thisStrat[, .(time = T_start, change = arr_at_T_start)],
        dt_history_thisStrat[, .(time = T_end, change = -dep_at_T_end)],
        use.names = T
      )
    } # end if absorbing vs. non-absorbing state
    
    # Remove rows with no change 
    dt_state_trace <- dt_state_trace # edit this
    
    # Sum changes that happened at the same time
    dt_state_trace <- dt_state_trace[, .(change = sum(change)), by=.(time)]
    
    #add occupants column, a cumulative sum of changes
    dt_state_trace[order(time), occupants := cumsum(change)]
    
    #add columns for state and strategy
    dt_state_trace[, state := state]
    dt_state_trace[, strategy := strat]
    
    #combine into dt_state_occupancy 
    dt_state_occupancy <- rbind( # no edits
      dt_state_occupancy,
      dt_state_trace,
      use.names = T
    )
  } # end loop over states
} # end loop over strategies

#add age column so we can plot by age instead of time
dt_state_occupancy[, age := NA] # edit this 

# Plot state occupancy by age by strategy
ggplot(data = dt_state_occupancy, aes(x=age, y=occupants, color=state))+
  geom_line()+
  facet_grid(cols = vars(strategy))

# Plot again zoomed into lower y axis values
#. (if zoom seems off, check that you've reset n_sim = 20,000 in setup section)
ggplot(data = dt_state_occupancy[state != "healthy"], aes(x=age, y=occupants, color=state))+
  geom_line()+
  facet_grid(cols = vars(strategy)) +
  coord_cartesian(ylim = c(0, 800))
 
```

# Last two questions

-   About how much time did you spend on the assignment? **Replace with your answer**

-   Did you find any errors or have suggestions to improve it? **Replace with your answer**

**Reminder:** If you commented out `n_sim <- 20000` above, remember to switch it back before your final render.

Fin.
