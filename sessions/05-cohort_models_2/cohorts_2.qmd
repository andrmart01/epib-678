---
title: "Cohort models 2"
subtitle: "EPIB  676 session 5, McGill University"
author: "Alton Russell"
date: "20 Jan 2026"
format: revealjs
editor: visual
---

## Packages

```{r}
#| echo: true
#library(heemod) #health economic markov models
library(tidyr) #for spread function for wide-to-long table formating
library(ggplot2) #plotting
library(expm) #raise matrices to exponents with %^%

#use install.packages("Package") for any you don't have already

theme_set(theme_bw()) #set ggplot theme
```

## Recall: Specify a discrete time CSTM

Transition matrix ($n_s \times n_s$, where $n_s$ is the number of states)

$$
P = \begin{array}{c}\begin{matrix}Healthy & moderate & severe & dead \end{matrix} 
\\\left[\ 
\begin{matrix}
p_{H \rightarrow H} & p_{H \rightarrow M} & p_{H \rightarrow S} & p_{H \rightarrow D}\\
p_{M \rightarrow H} & p_{M \rightarrow M} & p_{M \rightarrow S} & p_{M \rightarrow D}\\
p_{S \rightarrow H} & p_{S \rightarrow M} & p_{S \rightarrow S} & p_{S \rightarrow D}\\
p_{D \rightarrow H} & p_{D \rightarrow M} & p_{D \rightarrow S} & p_{D \rightarrow D}
\end{matrix}\ \right]
\end{array}
$$

Initial distribution: $m_0 = \begin{bmatrix} 2000 & 0 & 0 & 0 \end{bmatrix}$

Cycle length: 1 year; Number of cycles: $T=20$

## Recall: Run a discrete time CSTM

Matrix $M$ stores cohort distribution after each cycle

-   $n_s$ columns and $T+1$ rows (starts at $t=0$)

-   Row $t$ contains $m_t$, the cohort's dist'n after cycle $t$

To calculate rewards (costs or QALYs)

-   Specify reward vectors $c,q$ (state rewards only) or reward matrices $C,Q$ (have transition rewards)

-   Store in reward matrices $M_c, M_Q$.

-   Apply discount factor to row sums for net present cost/QALY

## Today

-   **Time-varying transitions**

-   Time-varying rewards

-   Capturing epidemiological outcomes

-   Discrete time errors

-   Project & open-source model presentation

## Limits of (pure) Markov model

-   Transition probabilities might depend on

    -   **simulation time:** how long the model has been running

    -   **state residence time:** how long someone has been in a state

-   Not allowed in a (pure) Markov model

-   **Matrix solution only works for a pure Markov model**

## Common time-varying transition

-   Over several years, cohort will die from "other causes" (not the disease modeled)

-   Prob. of other cause death changes with age

-   Usually approximated with country-specific life tables

-   [Canadian life tables available from StatsCan](https://www150.statcan.gc.ca/n1/pub/84-537-x/84-537-x2021001-eng.htm)

-   Use column "Death probability between age X and X+1"

## 2020 life table data for Canada

```{r}
#| echo: true
t_other_cause_death <- read.csv2("prob_death_by_age_2020_StatsCan.csv",
                                 sep=",")
t_other_cause_death$prob_death<-as.numeric(t_other_cause_death$prob_death)
ggplot(data=t_other_cause_death, aes(x=Age, y=prob_death))+
  geom_point()+geom_line()
```

## 3D transition arrays

-   Use if some transitions differ by cycle

    -   E.G., other cause death

-   A "**stack"** of transition matrices, one for each cycle

-   $P[i,j,t]$: transition prob. from state $i$ to state $j$ in cycle $t$

    -   Dim 1: "From" health state $1, ..., i, ... I$

    -   Dim 2: "To" health state $1, ... , j, ... , J$

    -   Dim 3: during cycle $1,\ldots,t,\ldots,T$

## One approach to age-specific OCM

Multiply all transitions by $(1 - P_{OCM})$ (age-specific probability of other cause mortality), then add $P_{OCM}$ to the probability of transitioning to death.

For $P_{i \rightarrow j}$ for all $i,j \neq Death$:

$$
P_{i \rightarrow j}^{adjusted} = P_{i \rightarrow j}^{orig} (1 - P_{OCM})
$$

For $P_{i \rightarrow D}$ for all $i \neq Death$:

$$
P_{i \rightarrow D}^{adjusted} = P_{i \rightarrow D}^{orig} (1 - P_{OCM})+P_{OCM}
$$

## Ex: transition from 'Moderate'

Without other cause mortality:

$$
\begin{array}{c}\begin{matrix}H & M & S & D \end{matrix} 
\\\left[\ 
\begin{matrix}
0.40 & 0.19 & 0.40 & 0.01\\
\end{matrix}\ \right]
\end{array}
$$

With $P_{OCM}=0.03$:

$$
\begin{array}{c}\begin{matrix} H & M & S & D \end{matrix} 
\\\left[\ 
\begin{matrix}
0.40(0.97) & 0.19(0.97) & 0.40(0.97) & 0.01(0.97)+0.03\\
\end{matrix}\ \right]
\end{array}
$$

$$
\begin{bmatrix}
0.388 & 0.1843 & 0.388 & 0.0397\\
\end{bmatrix}
$$

## Ex: model from last class (no OCM)

```{r}
#| echo: true
v_state_names <- c("H","M","S","D") #vector of state names
m_0 = matrix(c(2000, 0, 0, 0), nrow = 1, #initial dist
             dimnames = list(c(""), v_state_names)) 
n_cycles = 20; p_HtoM = 0.2; p_MtoH = 0.4; p_MtoS = 0.4; p_MtoD = 0.01; p_StoH = 0.1; p_StoD = 0.3
mat_P = matrix(c(1-p_HtoM, p_HtoM,                 0,                0,
                 p_MtoH,   1-p_MtoH-p_MtoS-p_MtoD, p_MtoS,          p_MtoD,
                 p_StoH,   0,                      1-p_StoH-p_StoD, p_StoD,
                 0,        0,                      0,                1), 
              nrow = 4, byrow = T,
              dimnames = list(v_state_names, v_state_names))
M = matrix(rep(0, 4*21), ncol=4,
           dimnames = list(0:20, c("H","M","S","D")))
for (i in 1:21){
  M[i,] <- m_0 %*% (mat_P %^% (i-1))
}

# Make cohort trace plot
t_trace <- as_tibble(M) #convert from matrix
t_trace$Cycle_num <- 0:20 #add col for cycle number
t_trace <- t_trace |> #Long to wide
  gather(key=State, value=Count, H:D) #wide to long format
```

## Ex: 3D transition array with OCM

Cycle length is 1 year, cohort is age 50 at time 0.

```{r}
#| echo: true
# Pre-allocate 3D transition array
arr_P <- array(0,
              dim=c(4, 4, 20),
              dimnames=list(v_state_names, v_state_names, 1:20))

# Fill in array with transition matrix for each cycle
for(cycle in 1:20){
  #.  cohort age at start of this cycle
  age = 50+cycle-1
  #.  get prob. other cause mortality from table
  p_OCM <- t_other_cause_death[t_other_cause_death$Age==age,"prob_death"]
  #.  Adjust all probs DOWN by 1 - p_OCM to "make room" for OCM
  mat_P_this_year = mat_P*(1-p_OCM)
  #.  Adjust prob. transitioning to death UP to account for OCM
  mat_P_this_year[,"D"]<-mat_P_this_year[,"D"]+p_OCM
  #.  Put adjusted transition matrix into the transition array
  arr_P[ , , cycle] <- mat_P_this_year
}

```

## Age-specific death: T array

```{r}
#| echo: true
#| eval: true

arr_P # inspect transition array
#Verify that for each cycle, rows of transition matrix sum to 1
for (cycle in 1:20){
  print(rowSums(arr_P[ , , cycle]))    }
```

## Calculate M matrix with age-specific OCM

```{r}
#| echo: true

M_OCM = matrix(0, ncol=4, nrow = 21,
               dimnames = list(paste0("t",0:20), c("H","M","S","D")))
M_OCM[1,] <- m_0 #save initial distribution of cohort
for (i in 1:20){ #calculate distribution after each cycle
  M_OCM[i+1,] <- M_OCM[i,] %*% arr_P[ , , i]
}
M_OCM
```

## Markov trace with and without age-specific other cause mortality

```{r}
#| echo: false
t_trace$scenario <- "No other cause mortality"

t_trace_OCM <- as_tibble(M_OCM) #convert from matrix
t_trace_OCM$Cycle_num <- 0:20 #add col for cycle number
t_trace_OCM <- t_trace_OCM |>
  gather(M, key=State, value=Count, H:D) #wide to long format
t_trace_OCM$scenario <- "With age-specific other cause mortality"
t_trace_compare <- rbind(t_trace, t_trace_OCM)
ggplot(data=t_trace_compare, aes(x=Cycle_num, y=Count, color=State))+
  geom_line()+geom_point()+
  facet_grid(cols = vars(scenario))
```

## Today

-   Time-varying transitions

-   **Time-varying rewards**

-   Capturing epidemiological outcomes

-   Discrete time errors

-   Project & open-source model presentation

## Recall: reward matrices

$$ 
\textbf{C}= 
\begin{bmatrix}
c_H & c_M+c_{H \rightarrow M} & c_S+c_{H \rightarrow S} & c_D+c_{H \rightarrow D}\\ 
c_H+c_{M \rightarrow H} & c_M & c_S+c_{M \rightarrow S} & c_D+c_{M \rightarrow D}\\ 
c_H+c_{S \rightarrow H} & c_M+c_{S \rightarrow M} & c_S & c_D+c_{S \rightarrow D}\\ 
c_H+c_{D \rightarrow H} & c_M+c_{D \rightarrow M} & c_S+c_{D \rightarrow S} & c_D 
\end{bmatrix},\\
\textbf{Q} =
\begin{bmatrix}
q_H & q_M+q_{H \rightarrow M} & q_S+q_{H \rightarrow S} & q_D+q_{H \rightarrow D}\\ 
q_H+q_{M \rightarrow H} & q_M & q_S+q_{M \rightarrow S} & q_D+q_{M \rightarrow D}\\ 
q_H+q_{S \rightarrow H} & q_M+q_{S \rightarrow M} & q_S & q_D+q_{S \rightarrow D}\\ 
q_H+q_{D \rightarrow H} & q_M+q_{D \rightarrow M} & q_S+q_{D \rightarrow S} & q_D 
\end{bmatrix}
$$

## Vary rewards with simulation time

-   Reward ***matrix*** assumes costs/QALYs don't depend on cycle number

-   Can use 3D ***array*** to assign different rewards by cycle

    -   $\textbf{C}[i,j,t]$ and $\textbf{Q}[i,j,t]$ contain rewards (state + transition) for person going from $i$ to $j$ in cycle $t$

    -   Can compute total rewards of people who end cycle $t$ in each state:

        -   $\hat{C}_t =m_{t-1} (P \bigodot C[:,:,t])$

        -   $\hat{Q}_t = m_{t-1} (P \bigodot Q[:,:,t])$

## Alternative: 2D matrix in-loop

If you don't like 3D arrays, you can generate cycle-specific 2D matrices within the for loop that loops over cycles.

```{r}
#| eval: false
#| echo: true
#Pseudocode, won't run without modifications
mat_M <- matrix(0, ncol=4, nrow = n_cycles+1,
           dimnames = list(0:n_cycles, c("H","M","S","D")))
v_costs_per_cycle <- matrix(0, nrow = ncycles, ncol=1)
v_QALYs_per_cycle <- matrix(0, nrow = ncycles, ncol=1)

mat_M[1, ] <- m_0 # initial distribution
for(i in 1:n_cycles){
  mat_P_cycle <- NA # Calculate transition matrix for this cycle
  mat_C_cycle <- NA # Calculate cost reward matrix for this cycle
  mat_Q_cycle <- NA # Calculate QALY reward matrix for this cycle
  
  M[i+1,] <- M[i,] %*% mat_T_cycle #update cohort distribution
  v_costs_per_cycle[i] <- sum(M[i+1,] %*% mat_C_cycle) #calculate costs
  v_QALYs_per_cycle[i] <- sum(M[i+1,] %*% mat_Q_cycle) #calculate QALYs
}
```

## Today

-   Time-varying transitions

-   Time-varying rewards

-   **Capturing epidemiological outcomes**

-   Discrete time errors

-   Project & open-source model presentation

## Why capture epidemiologic outcomes

-   Measure of intervention effectiveness

-   Of interest to decision makers

-   Can used to calibrate or validate your model (more later)

**Examples**: survival, prevalence, incidence, lifetime risk

## Survival

-   Number of people not dead at time $t$

-   For each cycle, sum all states (columns of $M$ matrix) except dead

    -   Equivalently, cohort size minus number in dead state

## Remaining life expectancy

Expected number of years before death. Integral of survival:

$$
LE = \int_{t=0}^\infty S(t)
$$

In model with discrete time, calculate as:

$$
LE = \Sigma_{t=0}^\infty S(t)
$$

Expected age at death = remaining life expectancy + cohorts age at $t=0$.

## Prevalence

-   Proportion of population alive in a health state at a specific time.

-   Calculated as ratio of number in state i over number in any state other than dead

-   If multiple model states correspond to health state (e.g., tunnel states), must add them together for the numerator

## Incidence

-   Proportion of population that enters health state during $t$

-   For a state $j$:

    -   $m_{t-1} P[:,j]$ is the number that **entered or stayed** in state $j$ in cycle $t$

    -   $m_{t-1}^j P[j,j]$ is the number **that stayed** in state $j$ in cycle $t$

    -   $m_{t-1} P[:,j] - m_{t-1}^j P[j,j]$ is the number **that entered** state $j$ in cycle $t$

-   Divide by number alive at time $t-1$ to make it a proportion

## Today

-   Time-varying transitions and reward**s**

-   Time-varying rewards

-   Capturing epidemiological outcomes

-   **Discrete time errors**

-   Project & open-source model presentation

## Two types of discrete time errors

Using a discrete time approximation for a continuous process can introduce two types

**Integration error:** error due to only allowing transitions at the end of discrete cycles

-   Corrections usually applied

**Embedding error:** misalignment between per-cycle transition probabilities and the underlying continuous process[^1]

[^1]: Source: [Graves et. al. 2021 MDM](https://doi.org/10.1177/0272989X21995805)

-   Not well-recognized; seldom corrected

## Discrete time integration error

-   In uncorrected models, transitions occur at cycle [**end**]{.underline}

-   In real life, transitions occur in continuous time

-   Transition probs. are cumulative probability of transitioning [**during**]{.underline} a cycle

## Discrete time integration error

[![](figs/discretation_error_updown.jpeg)](www.doi.org/10.1177/0272989X13501558)

[Naimark et. al. 2013](https://www.doi.org/10.1177/0272989X13501558)

## Fix 1: Shorter cycle lengths

As cycle length $\rightarrow$ 0, discretization error $\rightarrow$ 0.

**But**, more cycles means more compute needed, and may lead to less interpretable probabilities

Modelers usually use another fix

## Solutions to discrete time error

[![](figs/discretization_corrections.jpg){width="730"}](https://doi.org/10.1101/2020.07.27.20162651)

[Srivastava et. al. 2020](https://doi.org/10.1101/2020.07.27.20162651)

## Simpson's method

Numerical process to approximate integrating a curve

**Simpson's 1/3rd method** (quadratic approximation; requires even number of cycles):

-   Multiply reward by 1/3 for first and last cycle

-   In between, multiply by 4/3 for odd cycles and 2/3 for even

**Simpson's 3/8 method** (cubic approximation; requires that number of cycles are multiple of 3):

-   Multiply reward by 3/8 in first and last cycle

-   In between, multiply by 6/8 if mult. of 3 and 9/8 otherwise

## Cycle tree approach

-   **Intuition:** If individuals make transitions halfway through a cycle on average, they should incur half the cost (QALY) associated with their "from" state and half the cost (QALY) of their "to" state

-   Implementation similar to transition rewards using a reward matrix

$\hat{C}_t =m_{t-1} (P \bigodot C)$ or $\hat{Q}_t =m_{t-1} (P \bigodot Q)$ with C and Q as given on next slide

## Cycle tree transition reward matrices

$$
\textbf{C}= 
\begin{bmatrix}
c_H & .5c_H+.5c_M & .5c_H+.5c_S & .5c_H+.5c_D\\ 
.5c_M+.5c_H & c_M & .5c_M+.5c_S & .5c_M+.5c_D\\ 
.5c_S+.5c_H & .5c_S+.5c_M & c_S & .5c_S+.5c_D\\ 
.5c_D+.5c_H & .5c_D+.5c_M & .5c_D+.5c_S & c_D 
\end{bmatrix},\\
\textbf{Q} =
\begin{bmatrix}
q_H & .5q_H+.5q_M & .5q_H+.5q_S & .5q_H+.5q_D\\ 
.5q_M+.5q_H & q_M & .5q_M+.5q_S & .5q_M+.5q_D\\ 
.5q_S+.5q_H & .5q_S+.5q_M & q_S & .5q_S+.5q_D\\ 
.5q_D+.5q_H & .5q_D+.5q_M & .5q_D+.5q_S & q_D 
\end{bmatrix}
$$

## Comparing integration error corrections

Simpson rule and cycle tree method perform similarly. I find cycle tree method intuitive (and it doesn't matter if total number of cycles are a multiple of 2 or 3)

![[Naimark et. al. 2013](https://doi.org/10.1177/0272989X13501558)](figs/discrete_time_corrections_compare_ARedits.png)

## Embedding error

-   Misalignment between transition probabilities and underlying continuous-time process

-   Occurs when:

    -   literature-based parameters are transformed and embedded using common rate-to-prob formala $P = 1 - e^{-rt}$

    -   Competing events (transitions to \>1 state possible)

## Solving embedding error

Vast majority of analyses do not address. But you can:

-   Use continuous time rate matrix $Q$ to represent transition rates
-   Convert to discrete time transition matrix $P$ using matrix exponential: $P = e^{Qt}$

## Revisiting rate-to-prob formula

$$
p(t) = 1 - e^{-rt} \quad r = -\frac{1}{t}log(1-p)
$$

Exactly correct [**iff**]{.underline}:

-   Transitions are independent with constant average rate

    -   Poisson point process, exponentially distributed events

-   No competing events

    -   Only 1 possible transition from each state

## Continuous time rate matrix Q

-   Off-diagonal entries are transition rates $r_{i \rightarrow j}$
-   Diagonal entries are negative sum of rates out of state $i$
-   Rows sum to 0

$3x3$ example:

$$
Q =
\begin{bmatrix}
-(r_{1 \rightarrow 2}+r_{1 \rightarrow 3}) & r_{1 \rightarrow 2} & r_{1 \rightarrow 3}\\
r_{2 \rightarrow 1} & -(r_{2 \rightarrow 1}+r_{2 \rightarrow 3}) & r_{2 \rightarrow 3}\\
r_{3 \rightarrow 1} & r_{3 \rightarrow 2} & -(r_{3 \rightarrow 1}+r_{3 \rightarrow 2})
\end{bmatrix}
$$

## Rate matrix example

```{r}
#| eval: true
#| echo: true

rate_matrix <- matrix(
  data = c(
    -(2+1), 2, 1,
    0, 0, 0,
    0, 0, 0), byrow = T, nrow = 3,
  dimnames = list(
    from = c("A", "B", "C"),
    to = c("A", "B", "C"))
)
rate_matrix
```

Note: absorbing states have 0 rates out, so row of 0s

## Rate matrix → transition matrix

$$
T_{prob} = e^{Qt}
$$

$Q$ is the continuous rate matrix; $t$ is the discrete cycle length

```{r}
#| eval: true
#| echo: true
expm(rate_matrix*1) # 1 year transition matrix
expm(rate_matrix*0.25) # 0.25 year transition matrix
```

Note: calculate matrix exponential using $expm::expm()$

## Simulating single event

```{r}
#| eval: true
#| echo: true

# sample time-to-transition,  200,000 individual, 
time_to_B <- rexp(200000, rate = 2) # RATE: 2 transitions per person year
hist(time_to_B)
```

## Rate-to-prob works with single event

```{r}
#| eval: true
#| echo: true

mean(time_to_B) # Mean time to transition to B
median(time_to_B) # Median time to transition to B
# Percent transitioning to B within 1 year
sum(time_to_B < 1) / length(time_to_B) 
# 1-year transitioning prob using rate-to-prob
1-exp(-2*1) 
# Percent transitioning to B within 0.25 year
sum(time_to_B < .25) / length(time_to_B)
 # 0.25-year transition prob using rate-to-prob
1-exp(-2*0.25)
```

## Simulating competing events

```{r}
#| eval: true
#| echo: true

# sample time-to-transition,  200,000 individuals, 1 transition per person-year
time_to_C <- rexp(200000, rate = 1)

next_event <- ifelse(time_to_B<time_to_C,"B","C")
time_to_next_event <- pmin(time_to_B, time_to_C)

dt <- tibble("next_event" = next_event, "time" = time_to_next_event)
head(dt)
```

## Simulating competing events 1-year cycle

```{r}
#| eval: true
#| echo: true

# Simulated 1-year transtions from A
fromA_1yr <- c(
  "to A" = sum(dt$time >= 1),
  "to B" = sum(dt[next_event=="B",]$time < 1),
  "to C" = sum(dt[next_event=="C",]$time < 1))/nrow(dt)
fromA_1yr
expm(rate_matrix*1) # 1 year transition matrix
```

## Simulating competing events 0.25-year cycle

```{r}
#| eval: true
#| echo: true

# Simulated 0.25-year transtions from A
fromA_0.25yr <- c(
  "to A" = sum(dt$time >= 0.25),
  "to B" = sum(dt[next_event=="B",]$time < 0.25),
  "to C" = sum(dt[next_event=="C",]$time < 0.25))/nrow(dt)
fromA_0.25yr
expm(rate_matrix*0.25) # 1 year transition matrix
```

## What if B → A is possible?

```{r}
#| eval: true
#| echo: true

rate_matrix2 <- matrix(
  data = c(
    -(2+1), 2, 1,
    4, -4, 0,
    0, 0, 0), byrow = T, nrow = 3,
  dimnames = list(
    from = c("A", "B", "C"),
    to = c("A", "B", "C"))
)
rate_matrix2
```

## Simulating competing events

```{r}
#| eval: true
#| echo: true

# Simulated 1-year transtions from A
fromA <- c(
  "to A" = sum(dt$time >= 1),
  "to B" = sum(dt[next_event=="B",]$time < 1),
  "to C" = sum(dt[next_event=="C",]$time < 1))/nrow(dt)
fromA
expm(rate_matrix2*1) # 1 year transition matrix
```

**WHY THE MISMATCH?**

-   We are simulating a single jump process

-   Ignores transitions A → B → A

## To be continued...

-   Will discuss how to address embedding error where returning to states are possible in future class

-   For now, you should know that embedding error is an issue, though most analyses with discrete-time CSTM ignore it

## Today

-   Time-varying transitions

-   Time-varying rewards

-   Capturing epidemiological outcomes

-   Discrete time errors

-   **Project & open-source model presentation**

## Non-programming assignments

-   Presentation of a published open-source modelling analysis (Th 12 March)

-   Course project

    -   Proposal (due Fr 26 Feb)

    -   In-class presentation (Th 9 Apr)

    -   Report + code (Th 16 Apr)

[Information available in syllabus folder of class Github page](http://htmlpreview.github.io/?https://github.com/altonrus/epib-678/blob/main/syllabus/info_assignments_nonprogramming.html)

## Recap

-   If transitions or rewards are time-varying, can create 3D arrays and select "slice" for each cycle in a loop

-   Cycle tree method corrects discrete time error using a modified transition reward matrix

-   Epidemiological measures can be calculated from a cohort model

## Logistics

-   Complete readings before next class
-   **Assignment 1** due Friday, January 23 on MyCourses → Assignments
    -   [**New process:**]{.underline}submit Assignment 1 & 2 by uploading to OneDrive folder shared with you
-   **Assignment 2** Cohort state transition models available
    -   Due Friday, January 30
    -   **More time consuming than usual**
-   Office hours: Mondays 2:30pm to 3:30pm in conference room 1128
